// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_POLYGON_MODE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_POLYGON_MODE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_POLYGON_MODE: [PolygonMode; 3] = [
  PolygonMode::FILL,
  PolygonMode::LINE,
  PolygonMode::POINT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PolygonMode(pub i8);
#[allow(non_upper_case_globals)]
impl PolygonMode {
  pub const FILL: Self = Self(0);
  pub const LINE: Self = Self(1);
  pub const POINT: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FILL,
    Self::LINE,
    Self::POINT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FILL => Some("FILL"),
      Self::LINE => Some("LINE"),
      Self::POINT => Some("POINT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PolygonMode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PolygonMode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for PolygonMode {
    type Output = PolygonMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for PolygonMode {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PolygonMode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PolygonMode {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BLEND_FACTOR: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BLEND_FACTOR: i8 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BLEND_FACTOR: [BlendFactor; 15] = [
  BlendFactor::ZERO,
  BlendFactor::ONE,
  BlendFactor::SRC_COLOR,
  BlendFactor::ONE_MINUS_SRC_COLOR,
  BlendFactor::DST_COLOR,
  BlendFactor::ONE_MINUS_DST_COLOR,
  BlendFactor::SRC_ALPHA,
  BlendFactor::ONE_MINUS_SRC_ALPHA,
  BlendFactor::DST_ALPHA,
  BlendFactor::ONE_MINUS_DST_ALPHA,
  BlendFactor::CONSTANT_COLOR,
  BlendFactor::ONE_MINUS_CONSTANT_COLOR,
  BlendFactor::CONSTANT_ALPHA,
  BlendFactor::ONE_MINUS_CONSTANT_ALPHA,
  BlendFactor::SRC_ALPHA_SATURATE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BlendFactor(pub i8);
#[allow(non_upper_case_globals)]
impl BlendFactor {
  pub const ZERO: Self = Self(0);
  pub const ONE: Self = Self(1);
  pub const SRC_COLOR: Self = Self(2);
  pub const ONE_MINUS_SRC_COLOR: Self = Self(3);
  pub const DST_COLOR: Self = Self(4);
  pub const ONE_MINUS_DST_COLOR: Self = Self(5);
  pub const SRC_ALPHA: Self = Self(6);
  pub const ONE_MINUS_SRC_ALPHA: Self = Self(7);
  pub const DST_ALPHA: Self = Self(8);
  pub const ONE_MINUS_DST_ALPHA: Self = Self(9);
  pub const CONSTANT_COLOR: Self = Self(10);
  pub const ONE_MINUS_CONSTANT_COLOR: Self = Self(11);
  pub const CONSTANT_ALPHA: Self = Self(12);
  pub const ONE_MINUS_CONSTANT_ALPHA: Self = Self(13);
  pub const SRC_ALPHA_SATURATE: Self = Self(14);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ZERO,
    Self::ONE,
    Self::SRC_COLOR,
    Self::ONE_MINUS_SRC_COLOR,
    Self::DST_COLOR,
    Self::ONE_MINUS_DST_COLOR,
    Self::SRC_ALPHA,
    Self::ONE_MINUS_SRC_ALPHA,
    Self::DST_ALPHA,
    Self::ONE_MINUS_DST_ALPHA,
    Self::CONSTANT_COLOR,
    Self::ONE_MINUS_CONSTANT_COLOR,
    Self::CONSTANT_ALPHA,
    Self::ONE_MINUS_CONSTANT_ALPHA,
    Self::SRC_ALPHA_SATURATE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ZERO => Some("ZERO"),
      Self::ONE => Some("ONE"),
      Self::SRC_COLOR => Some("SRC_COLOR"),
      Self::ONE_MINUS_SRC_COLOR => Some("ONE_MINUS_SRC_COLOR"),
      Self::DST_COLOR => Some("DST_COLOR"),
      Self::ONE_MINUS_DST_COLOR => Some("ONE_MINUS_DST_COLOR"),
      Self::SRC_ALPHA => Some("SRC_ALPHA"),
      Self::ONE_MINUS_SRC_ALPHA => Some("ONE_MINUS_SRC_ALPHA"),
      Self::DST_ALPHA => Some("DST_ALPHA"),
      Self::ONE_MINUS_DST_ALPHA => Some("ONE_MINUS_DST_ALPHA"),
      Self::CONSTANT_COLOR => Some("CONSTANT_COLOR"),
      Self::ONE_MINUS_CONSTANT_COLOR => Some("ONE_MINUS_CONSTANT_COLOR"),
      Self::CONSTANT_ALPHA => Some("CONSTANT_ALPHA"),
      Self::ONE_MINUS_CONSTANT_ALPHA => Some("ONE_MINUS_CONSTANT_ALPHA"),
      Self::SRC_ALPHA_SATURATE => Some("SRC_ALPHA_SATURATE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BlendFactor {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BlendFactor {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for BlendFactor {
    type Output = BlendFactor;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for BlendFactor {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BlendFactor {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BlendFactor {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FORMAT: u16 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FORMAT: u16 = 126;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FORMAT: [Format; 4] = [
  Format::UNDEFINED,
  Format::R8G8B8A8_UNORM,
  Format::D24_UNORM_S8_UINT,
  Format::D32_SFLOAT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Format(pub u16);
#[allow(non_upper_case_globals)]
impl Format {
  pub const UNDEFINED: Self = Self(0);
  pub const R8G8B8A8_UNORM: Self = Self(37);
  pub const D24_UNORM_S8_UINT: Self = Self(45);
  pub const D32_SFLOAT: Self = Self(126);

  pub const ENUM_MIN: u16 = 0;
  pub const ENUM_MAX: u16 = 126;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNDEFINED,
    Self::R8G8B8A8_UNORM,
    Self::D24_UNORM_S8_UINT,
    Self::D32_SFLOAT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UNDEFINED => Some("UNDEFINED"),
      Self::R8G8B8A8_UNORM => Some("R8G8B8A8_UNORM"),
      Self::D24_UNORM_S8_UINT => Some("D24_UNORM_S8_UINT"),
      Self::D32_SFLOAT => Some("D32_SFLOAT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Format {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Format {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<u16>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for Format {
    type Output = Format;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<u16>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Format {
  type Scalar = u16;
  #[inline]
  fn to_little_endian(self) -> u16 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u16) -> Self {
    let b = u16::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Format {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u16::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Format {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BLEND_OP: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BLEND_OP: i8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BLEND_OP: [BlendOp; 5] = [
  BlendOp::ADD,
  BlendOp::SUBTRACT,
  BlendOp::REVERSE_SUBTRACT,
  BlendOp::MIN,
  BlendOp::MAX,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BlendOp(pub i8);
#[allow(non_upper_case_globals)]
impl BlendOp {
  pub const ADD: Self = Self(0);
  pub const SUBTRACT: Self = Self(1);
  pub const REVERSE_SUBTRACT: Self = Self(2);
  pub const MIN: Self = Self(3);
  pub const MAX: Self = Self(4);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ADD,
    Self::SUBTRACT,
    Self::REVERSE_SUBTRACT,
    Self::MIN,
    Self::MAX,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ADD => Some("ADD"),
      Self::SUBTRACT => Some("SUBTRACT"),
      Self::REVERSE_SUBTRACT => Some("REVERSE_SUBTRACT"),
      Self::MIN => Some("MIN"),
      Self::MAX => Some("MAX"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BlendOp {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BlendOp {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<i8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for BlendOp {
    type Output = BlendOp;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for BlendOp {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BlendOp {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BlendOp {}
// struct Magic, aligned to 1
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Magic(pub [u8; 4]);
impl Default for Magic { 
  fn default() -> Self { 
    Self([0; 4])
  }
}
impl core::fmt::Debug for Magic {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Magic")
      .field("data", &self.data())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Magic {}
impl<'a> flatbuffers::Follow<'a> for Magic {
  type Inner = &'a Magic;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { <&'a Magic>::follow(buf, loc) }
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Magic {
  type Inner = &'a Magic;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { flatbuffers::follow_cast_ref::<Magic>(buf, loc) }
  }
}
impl<'b> flatbuffers::Push for Magic {
    type Output = Magic;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = unsafe { ::core::slice::from_raw_parts(self as *const Magic as *const u8, <Self as flatbuffers::Push>::size()) };
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(1)
    }
}

impl<'a> flatbuffers::Verifiable for Magic {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Magic {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    data: &[u8; 4],
  ) -> Self {
    let mut s = Self([0; 4]);
    s.set_data(data);
    s
  }

  pub fn data(&'a self) -> flatbuffers::Array<'a, u8, 4> {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid array in this slot
    unsafe { flatbuffers::Array::follow(&self.0, 0) }
  }

  pub fn set_data(&mut self, items: &[u8; 4]) {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid array in this slot
    unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
  }

}

// struct DepthStencilStateBlock, aligned to 2
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct DepthStencilStateBlock(pub [u8; 4]);
impl Default for DepthStencilStateBlock { 
  fn default() -> Self { 
    Self([0; 4])
  }
}
impl core::fmt::Debug for DepthStencilStateBlock {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("DepthStencilStateBlock")
      .field("format", &self.format())
      .field("depth_test_enable", &self.depth_test_enable())
      .field("depth_write_enable", &self.depth_write_enable())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DepthStencilStateBlock {}
impl<'a> flatbuffers::Follow<'a> for DepthStencilStateBlock {
  type Inner = &'a DepthStencilStateBlock;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { <&'a DepthStencilStateBlock>::follow(buf, loc) }
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a DepthStencilStateBlock {
  type Inner = &'a DepthStencilStateBlock;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { flatbuffers::follow_cast_ref::<DepthStencilStateBlock>(buf, loc) }
  }
}
impl<'b> flatbuffers::Push for DepthStencilStateBlock {
    type Output = DepthStencilStateBlock;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = unsafe { ::core::slice::from_raw_parts(self as *const DepthStencilStateBlock as *const u8, <Self as flatbuffers::Push>::size()) };
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(2)
    }
}

impl<'a> flatbuffers::Verifiable for DepthStencilStateBlock {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> DepthStencilStateBlock {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    format: Format,
    depth_test_enable: bool,
    depth_write_enable: bool,
  ) -> Self {
    let mut s = Self([0; 4]);
    s.set_format(format);
    s.set_depth_test_enable(depth_test_enable);
    s.set_depth_write_enable(depth_write_enable);
    s
  }

  pub fn format(&self) -> Format {
    let mut mem = core::mem::MaybeUninit::<<Format as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<Format as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_format(&mut self, x: Format) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<Format as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn depth_test_enable(&self) -> bool {
    let mut mem = core::mem::MaybeUninit::<<bool as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[2..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_depth_test_enable(&mut self, x: bool) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[2..].as_mut_ptr(),
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn depth_write_enable(&self) -> bool {
    let mut mem = core::mem::MaybeUninit::<<bool as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[3..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_depth_write_enable(&mut self, x: bool) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[3..].as_mut_ptr(),
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct ColorBlendStateBlock, aligned to 1
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct ColorBlendStateBlock(pub [u8; 7]);
impl Default for ColorBlendStateBlock { 
  fn default() -> Self { 
    Self([0; 7])
  }
}
impl core::fmt::Debug for ColorBlendStateBlock {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("ColorBlendStateBlock")
      .field("blend_enable", &self.blend_enable())
      .field("src_color_blend_factor", &self.src_color_blend_factor())
      .field("dst_color_blend_factor", &self.dst_color_blend_factor())
      .field("color_blend_op", &self.color_blend_op())
      .field("src_alpha_blend_factor", &self.src_alpha_blend_factor())
      .field("dst_alpha_blend_factor", &self.dst_alpha_blend_factor())
      .field("alpha_blend_op", &self.alpha_blend_op())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ColorBlendStateBlock {}
impl<'a> flatbuffers::Follow<'a> for ColorBlendStateBlock {
  type Inner = &'a ColorBlendStateBlock;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { <&'a ColorBlendStateBlock>::follow(buf, loc) }
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a ColorBlendStateBlock {
  type Inner = &'a ColorBlendStateBlock;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { flatbuffers::follow_cast_ref::<ColorBlendStateBlock>(buf, loc) }
  }
}
impl<'b> flatbuffers::Push for ColorBlendStateBlock {
    type Output = ColorBlendStateBlock;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = unsafe { ::core::slice::from_raw_parts(self as *const ColorBlendStateBlock as *const u8, <Self as flatbuffers::Push>::size()) };
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(1)
    }
}

impl<'a> flatbuffers::Verifiable for ColorBlendStateBlock {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> ColorBlendStateBlock {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    blend_enable: bool,
    src_color_blend_factor: BlendFactor,
    dst_color_blend_factor: BlendFactor,
    color_blend_op: BlendOp,
    src_alpha_blend_factor: BlendFactor,
    dst_alpha_blend_factor: BlendFactor,
    alpha_blend_op: BlendOp,
  ) -> Self {
    let mut s = Self([0; 7]);
    s.set_blend_enable(blend_enable);
    s.set_src_color_blend_factor(src_color_blend_factor);
    s.set_dst_color_blend_factor(dst_color_blend_factor);
    s.set_color_blend_op(color_blend_op);
    s.set_src_alpha_blend_factor(src_alpha_blend_factor);
    s.set_dst_alpha_blend_factor(dst_alpha_blend_factor);
    s.set_alpha_blend_op(alpha_blend_op);
    s
  }

  pub fn blend_enable(&self) -> bool {
    let mut mem = core::mem::MaybeUninit::<<bool as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_blend_enable(&mut self, x: bool) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn src_color_blend_factor(&self) -> BlendFactor {
    let mut mem = core::mem::MaybeUninit::<<BlendFactor as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[1..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<BlendFactor as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_src_color_blend_factor(&mut self, x: BlendFactor) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[1..].as_mut_ptr(),
        core::mem::size_of::<<BlendFactor as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn dst_color_blend_factor(&self) -> BlendFactor {
    let mut mem = core::mem::MaybeUninit::<<BlendFactor as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[2..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<BlendFactor as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_dst_color_blend_factor(&mut self, x: BlendFactor) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[2..].as_mut_ptr(),
        core::mem::size_of::<<BlendFactor as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn color_blend_op(&self) -> BlendOp {
    let mut mem = core::mem::MaybeUninit::<<BlendOp as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[3..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<BlendOp as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_color_blend_op(&mut self, x: BlendOp) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[3..].as_mut_ptr(),
        core::mem::size_of::<<BlendOp as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn src_alpha_blend_factor(&self) -> BlendFactor {
    let mut mem = core::mem::MaybeUninit::<<BlendFactor as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<BlendFactor as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_src_alpha_blend_factor(&mut self, x: BlendFactor) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<BlendFactor as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn dst_alpha_blend_factor(&self) -> BlendFactor {
    let mut mem = core::mem::MaybeUninit::<<BlendFactor as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[5..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<BlendFactor as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_dst_alpha_blend_factor(&mut self, x: BlendFactor) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[5..].as_mut_ptr(),
        core::mem::size_of::<<BlendFactor as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn alpha_blend_op(&self) -> BlendOp {
    let mut mem = core::mem::MaybeUninit::<<BlendOp as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[6..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<BlendOp as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_alpha_blend_op(&mut self, x: BlendOp) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[6..].as_mut_ptr(),
        core::mem::size_of::<<BlendOp as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct ColorTarget, aligned to 2
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct ColorTarget(pub [u8; 10]);
impl Default for ColorTarget { 
  fn default() -> Self { 
    Self([0; 10])
  }
}
impl core::fmt::Debug for ColorTarget {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("ColorTarget")
      .field("format", &self.format())
      .field("blend", &self.blend())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ColorTarget {}
impl<'a> flatbuffers::Follow<'a> for ColorTarget {
  type Inner = &'a ColorTarget;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { <&'a ColorTarget>::follow(buf, loc) }
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a ColorTarget {
  type Inner = &'a ColorTarget;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { flatbuffers::follow_cast_ref::<ColorTarget>(buf, loc) }
  }
}
impl<'b> flatbuffers::Push for ColorTarget {
    type Output = ColorTarget;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = unsafe { ::core::slice::from_raw_parts(self as *const ColorTarget as *const u8, <Self as flatbuffers::Push>::size()) };
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(2)
    }
}

impl<'a> flatbuffers::Verifiable for ColorTarget {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> ColorTarget {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    format: Format,
    blend: &ColorBlendStateBlock,
  ) -> Self {
    let mut s = Self([0; 10]);
    s.set_format(format);
    s.set_blend(blend);
    s
  }

  pub fn format(&self) -> Format {
    let mut mem = core::mem::MaybeUninit::<<Format as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<Format as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_format(&mut self, x: Format) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<Format as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn blend(&self) -> &ColorBlendStateBlock {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[2..].as_ptr() as *const ColorBlendStateBlock) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_blend(&mut self, x: &ColorBlendStateBlock) {
    self.0[2..2 + 7].copy_from_slice(&x.0)
  }

}

// struct RasterizerStateBlock, aligned to 1
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct RasterizerStateBlock(pub [u8; 1]);
impl Default for RasterizerStateBlock { 
  fn default() -> Self { 
    Self([0; 1])
  }
}
impl core::fmt::Debug for RasterizerStateBlock {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("RasterizerStateBlock")
      .field("polygon_mode", &self.polygon_mode())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for RasterizerStateBlock {}
impl<'a> flatbuffers::Follow<'a> for RasterizerStateBlock {
  type Inner = &'a RasterizerStateBlock;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { <&'a RasterizerStateBlock>::follow(buf, loc) }
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a RasterizerStateBlock {
  type Inner = &'a RasterizerStateBlock;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { flatbuffers::follow_cast_ref::<RasterizerStateBlock>(buf, loc) }
  }
}
impl<'b> flatbuffers::Push for RasterizerStateBlock {
    type Output = RasterizerStateBlock;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = unsafe { ::core::slice::from_raw_parts(self as *const RasterizerStateBlock as *const u8, <Self as flatbuffers::Push>::size()) };
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(1)
    }
}

impl<'a> flatbuffers::Verifiable for RasterizerStateBlock {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> RasterizerStateBlock {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    polygon_mode: PolygonMode,
  ) -> Self {
    let mut s = Self([0; 1]);
    s.set_polygon_mode(polygon_mode);
    s
  }

  pub fn polygon_mode(&self) -> PolygonMode {
    let mut mem = core::mem::MaybeUninit::<<PolygonMode as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<PolygonMode as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_polygon_mode(&mut self, x: PolygonMode) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<PolygonMode as EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum ArchiveHeaderOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ArchiveHeader<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArchiveHeader<'a> {
  type Inner = ArchiveHeader<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ArchiveHeader<'a> {
  pub const VT_MAGIC: flatbuffers::VOffsetT = 4;
  pub const VT_VERSION: flatbuffers::VOffsetT = 6;
  pub const VT_FILE_COUNT: flatbuffers::VOffsetT = 8;
  pub const VT_ENTRIES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArchiveHeader { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ArchiveHeaderArgs<'args>
  ) -> flatbuffers::WIPOffset<ArchiveHeader<'bldr>> {
    let mut builder = ArchiveHeaderBuilder::new(_fbb);
    if let Some(x) = args.entries { builder.add_entries(x); }
    builder.add_file_count(args.file_count);
    if let Some(x) = args.magic { builder.add_magic(x); }
    builder.add_version(args.version);
    builder.finish()
  }


  #[inline]
  pub fn magic(&self) -> Option<&'a Magic> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Magic>(ArchiveHeader::VT_MAGIC, None)}
  }
  #[inline]
  pub fn version(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(ArchiveHeader::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn file_count(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ArchiveHeader::VT_FILE_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn entries(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PipelineEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PipelineEntry>>>>(ArchiveHeader::VT_ENTRIES, None)}
  }
}

impl flatbuffers::Verifiable for ArchiveHeader<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Magic>("magic", Self::VT_MAGIC, false)?
     .visit_field::<u16>("version", Self::VT_VERSION, false)?
     .visit_field::<u32>("file_count", Self::VT_FILE_COUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PipelineEntry>>>>("entries", Self::VT_ENTRIES, false)?
     .finish();
    Ok(())
  }
}
pub struct ArchiveHeaderArgs<'a> {
    pub magic: Option<&'a Magic>,
    pub version: u16,
    pub file_count: u32,
    pub entries: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PipelineEntry<'a>>>>>,
}
impl<'a> Default for ArchiveHeaderArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArchiveHeaderArgs {
      magic: None,
      version: 0,
      file_count: 0,
      entries: None,
    }
  }
}

pub struct ArchiveHeaderBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ArchiveHeaderBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_magic(&mut self, magic: &Magic) {
    self.fbb_.push_slot_always::<&Magic>(ArchiveHeader::VT_MAGIC, magic);
  }
  #[inline]
  pub fn add_version(&mut self, version: u16) {
    self.fbb_.push_slot::<u16>(ArchiveHeader::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_file_count(&mut self, file_count: u32) {
    self.fbb_.push_slot::<u32>(ArchiveHeader::VT_FILE_COUNT, file_count, 0);
  }
  #[inline]
  pub fn add_entries(&mut self, entries: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PipelineEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ArchiveHeader::VT_ENTRIES, entries);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ArchiveHeaderBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ArchiveHeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArchiveHeader<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArchiveHeader<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArchiveHeader");
      ds.field("magic", &self.magic());
      ds.field("version", &self.version());
      ds.field("file_count", &self.file_count());
      ds.field("entries", &self.entries());
      ds.finish()
  }
}
pub enum PipelineEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PipelineEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PipelineEntry<'a> {
  type Inner = PipelineEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> PipelineEntry<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_TAGS: flatbuffers::VOffsetT = 6;
  pub const VT_DEPTH_STENCIL: flatbuffers::VOffsetT = 8;
  pub const VT_RASTERIZER: flatbuffers::VOffsetT = 10;
  pub const VT_COLOR_TARGETS: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PipelineEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PipelineEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<PipelineEntry<'bldr>> {
    let mut builder = PipelineEntryBuilder::new(_fbb);
    if let Some(x) = args.color_targets { builder.add_color_targets(x); }
    if let Some(x) = args.rasterizer { builder.add_rasterizer(x); }
    if let Some(x) = args.depth_stencil { builder.add_depth_stencil(x); }
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PipelineEntry::VT_NAME, None)}
  }
  #[inline]
  pub fn tags(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(PipelineEntry::VT_TAGS, None)}
  }
  #[inline]
  pub fn depth_stencil(&self) -> Option<&'a DepthStencilStateBlock> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DepthStencilStateBlock>(PipelineEntry::VT_DEPTH_STENCIL, None)}
  }
  #[inline]
  pub fn rasterizer(&self) -> Option<&'a RasterizerStateBlock> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<RasterizerStateBlock>(PipelineEntry::VT_RASTERIZER, None)}
  }
  #[inline]
  pub fn color_targets(&self) -> Option<flatbuffers::Vector<'a, ColorTarget>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ColorTarget>>>(PipelineEntry::VT_COLOR_TARGETS, None)}
  }
}

impl flatbuffers::Verifiable for PipelineEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("tags", Self::VT_TAGS, false)?
     .visit_field::<DepthStencilStateBlock>("depth_stencil", Self::VT_DEPTH_STENCIL, false)?
     .visit_field::<RasterizerStateBlock>("rasterizer", Self::VT_RASTERIZER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ColorTarget>>>("color_targets", Self::VT_COLOR_TARGETS, false)?
     .finish();
    Ok(())
  }
}
pub struct PipelineEntryArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub tags: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub depth_stencil: Option<&'a DepthStencilStateBlock>,
    pub rasterizer: Option<&'a RasterizerStateBlock>,
    pub color_targets: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ColorTarget>>>,
}
impl<'a> Default for PipelineEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    PipelineEntryArgs {
      name: None,
      tags: None,
      depth_stencil: None,
      rasterizer: None,
      color_targets: None,
    }
  }
}

pub struct PipelineEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PipelineEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PipelineEntry::VT_NAME, name);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PipelineEntry::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_depth_stencil(&mut self, depth_stencil: &DepthStencilStateBlock) {
    self.fbb_.push_slot_always::<&DepthStencilStateBlock>(PipelineEntry::VT_DEPTH_STENCIL, depth_stencil);
  }
  #[inline]
  pub fn add_rasterizer(&mut self, rasterizer: &RasterizerStateBlock) {
    self.fbb_.push_slot_always::<&RasterizerStateBlock>(PipelineEntry::VT_RASTERIZER, rasterizer);
  }
  #[inline]
  pub fn add_color_targets(&mut self, color_targets: flatbuffers::WIPOffset<flatbuffers::Vector<'b , ColorTarget>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PipelineEntry::VT_COLOR_TARGETS, color_targets);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PipelineEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PipelineEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PipelineEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PipelineEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PipelineEntry");
      ds.field("name", &self.name());
      ds.field("tags", &self.tags());
      ds.field("depth_stencil", &self.depth_stencil());
      ds.field("rasterizer", &self.rasterizer());
      ds.field("color_targets", &self.color_targets());
      ds.finish()
  }
}

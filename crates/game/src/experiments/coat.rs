use crate::experiments::lines::{Line, LineVertex, draw_lines};
use crate::{SceneInfo, SceneInfoUniforms};
use color::srgba8;
use gamelib::asset::{AssetCache, Handle};
use gamelib::input::InputEvent;
use gamelib::pipeline_cache::{get_compute_pipeline, get_graphics_pipeline};
use gpu::PrimitiveTopology::TriangleList;
use gpu::{BufferUsage, RenderPassInfo};

/// Post-stroke expansion vertex, already in clip space.
#[repr(C)]
#[derive(Clone, Copy)]
struct ExpandedVertex {
    clip_pos: math::Vec4,
    color: color::Srgba8,
}

struct CoatData {
    stroke_vertex_buffer: gpu::Buffer<[geom::StrokeVertex]>,
    stroke_buffer: gpu::Buffer<[geom::Stroke]>,
    mesh_vertex_buffer: gpu::Buffer<[geom::mesh::MeshVertex]>,
    mesh_index_buffer: gpu::Buffer<[u32]>,

    /// Holds vertices generated by stroke expansion.
    expansion_vertices: gpu::Buffer<[ExpandedVertex]>,
    /// Holds indices generated by stroke expansion.
    expansion_indices: gpu::Buffer<[u32]>,
}

pub struct CoatExperiment {
    geometry: Option<geom::GeoArchive>,
    gpu_data: Option<CoatData>,
    expand_stroke_pipeline: Handle<gpu::ComputePipeline>,
    sweep_stroke_pipeline: Handle<gpu::ComputePipeline>,
    debug_stroke_pipeline: Handle<gpu::GraphicsPipeline>,
}

/*
struct ExpandStrokesData {
    Stroke *strokes;
    StrokeVertex *vertices;
    ExpandedStrokeVertex* out_vertices;
    uint* out_indices;
    Atomic<uint32_t> out_vertex_ptr;
    Atomic<uint32_t> out_index_ptr;
    float main_width;
    float border_width;
};

struct ExpandStrokesPushConstants {
    SceneInfo *scene_info;
    ExpandStrokesData* data;
};*/

#[repr(C)]
#[derive(Clone, Copy)]
struct PushBuffer<T: Copy + 'static> {
    base: gpu::Ptr<[T]>,
    offset: u32,
    capacity: u32,
}

impl<T: Copy + 'static> PushBuffer<T> {
    fn new(buffer: &gpu::Buffer<[T]>) -> Self {
        Self {
            base: buffer.ptr(),
            offset: 0,
            capacity: buffer.len() as u32,
        }
    }
}

#[repr(C)]
#[derive(Clone, Copy)]
struct ExpandStrokesData {
    strokes: gpu::Ptr<[geom::Stroke]>,
    vertices: gpu::Ptr<[geom::StrokeVertex]>,

    out_vertices: PushBuffer<ExpandedVertex>,
    out_indices: PushBuffer<u32>,

    main_width: f32,
    border_width: f32,
}

#[repr(C)]
#[derive(Clone, Copy)]
struct ExpandStrokesRootParams {
    scene_info: gpu::Ptr<SceneInfoUniforms>,
    data: gpu::Ptr<ExpandStrokesData>,
}

/*
struct DebugStrokesPushConstants {
    SceneInfo* scene_info;
    ExpandedStrokeVertex* vertices;
    uint* indices;
};*/

#[repr(C)]
#[derive(Clone, Copy)]
struct DebugStrokesRootParams {
    scene_info: gpu::Ptr<SceneInfoUniforms>,
    vertices: gpu::Ptr<[ExpandedVertex]>,
    indices: gpu::Ptr<[u32]>,
}

const NVERTEX: usize = 9;

impl CoatExperiment {
    pub(crate) fn new() -> Self {
        Self {
            geometry: None,
            gpu_data: None,
            expand_stroke_pipeline: get_compute_pipeline("/shaders/pipelines.parc#expand_strokes"),
            sweep_stroke_pipeline: get_compute_pipeline("/shaders/pipelines.parc#sweep_stroke"),
            debug_stroke_pipeline: get_graphics_pipeline("/shaders/pipelines.parc#debug_strokes"),
        }
    }

    pub(crate) fn input(&mut self, input_event: &InputEvent) {
        if input_event.is_shortcut("Ctrl+O") {
            self.open();
        }
    }

    fn open(&mut self) {
        if let Some(path) = rfd::FileDialog::new()
            .add_filter("Geometry Archive", &["geom"])
            .pick_file()
        {
            match geom::GeoArchive::load(&path) {
                Ok(geo) => {
                    self.geometry = Some(geo);
                    self.gpu_data = None;
                    println!("Loaded geometry archive: {:?}", path);
                    // Further processing can be done here
                }
                Err(e) => {
                    eprintln!("Failed to load geometry archive: {}", e);
                }
            }
        }
    }

    /// Update geometry buffers on the GPU.
    fn update_geometry(&mut self, _cmd: &mut gpu::CommandStream) {
        if self.geometry.is_none() {
            return;
        }
        if self.gpu_data.is_some() {
            return;
        }

        let geometry = self.geometry.as_ref().unwrap();
        self.gpu_data = None;

        let header = geometry.header();
        let strokes = gpu::Buffer::from_slice(geometry.strokes(), "strokes");
        let stroke_vertices = gpu::Buffer::from_slice(geometry.stroke_vertices(), "stroke_vertices");
        let mesh_vertices = gpu::Buffer::from_slice(geometry.mesh_vertices(), "mesh_vertices");
        let mesh_indices = gpu::Buffer::from_slice(geometry.indices(), "mesh_indices");

        let expansion_buffer_size = stroke_vertices.len() * NVERTEX;
        let expansion_vertices = gpu::Buffer::new(gpu::BufferCreateInfo {
            len: expansion_buffer_size,
            label: "expansion_buffer",
            ..
        });
        let expansion_indices = gpu::Buffer::new(gpu::BufferCreateInfo {
            len: stroke_vertices.len() * (NVERTEX - 1) * 6,
            label: "expansion_indices",
            ..
        });

        self.gpu_data = Some(CoatData {
            stroke_vertex_buffer: stroke_vertices,
            stroke_buffer: strokes,
            mesh_vertex_buffer: mesh_vertices,
            mesh_index_buffer: mesh_indices,
            expansion_vertices,
            expansion_indices,
        });
    }

    pub(crate) fn render(
        &mut self,
        cmd: &mut gpu::CommandStream,
        color_target: &gpu::Image,
        depth_target: &gpu::Image,
        scene_info: &SceneInfo,
    ) {
        if self.gpu_data.is_none() {
            self.update_geometry(cmd);
        }

        let Some(geometry) = &self.geometry else {
            return;
        };
        //let header = geometry.header();

        let Some(gpu_data) = &self.gpu_data else {
            return;
        };

        let strokes = geometry.strokes();
        let stroke_vertices = geometry.stroke_vertices();
        let coats = geometry.coats();

        let mut line_vertices = Vec::new();
        let mut lines = Vec::new();
        for coat in coats {
            let stroke_range = coat.start_stroke as usize..(coat.start_stroke + coat.stroke_count) as usize;
            for stroke in &strokes[stroke_range] {
                let vertex_range = stroke.start_vertex as usize..(stroke.start_vertex + stroke.vertex_count) as usize;
                let start_vertex = line_vertices.len() as u32;

                if stroke.vertex_count > 32 {
                    //eprintln!("Large stroke: vertex_count={}", stroke.vertex_count);
                }

                for v in &stroke_vertices[vertex_range] {
                    //eprintln!("coat: v={:?}", v);
                    line_vertices.push(LineVertex {
                        position: v.position,
                        color: srgba8(0, 0, 0, 255),
                    });
                }
                lines.push(Line {
                    start_vertex,
                    vertex_count: stroke.vertex_count,
                    width: 5.0,
                    ..
                })
            }
        }

        ///////////////////////////////////////////////////////////////////////////////////////////

        let Ok(expand_stroke_pipeline) = self.expand_stroke_pipeline.read() else {
            return;
        };

        cmd.fill_buffer(&gpu_data.expansion_vertices.as_bytes().slice(..), 0);
        cmd.fill_buffer(&gpu_data.expansion_indices.as_bytes().slice(..), 0);

        let params = cmd.upload_temporary(&ExpandStrokesData {
            strokes: gpu_data.stroke_buffer.ptr(),
            vertices: gpu_data.stroke_vertex_buffer.ptr(),
            out_vertices: PushBuffer::new(&gpu_data.expansion_vertices),
            out_indices: PushBuffer::new(&gpu_data.expansion_indices),
            main_width: 0.08,
            border_width: 5.0,
        });

        cmd.reference_resource(&gpu_data.stroke_buffer);
        cmd.reference_resource(&gpu_data.stroke_vertex_buffer);
        cmd.reference_resource(&gpu_data.expansion_vertices);
        cmd.reference_resource(&gpu_data.expansion_indices);
        cmd.bind_compute_pipeline(&*expand_stroke_pipeline);
        let workgroup_count = gpu_data.stroke_buffer.len() as u32;
        cmd.dispatch(workgroup_count, 1, 1, &ExpandStrokesRootParams {
            scene_info: scene_info.gpu,
            data: params,
        });

        //////////////////////////////////////////////////////////////////////////////////////////
        let Ok(debug_stroke_pipeline) = self.debug_stroke_pipeline.read() else {
            return;
        };
        let mut encoder = cmd.begin_rendering(RenderPassInfo {
            color_attachments: &[gpu::ColorAttachment {
                image: color_target,
                clear_value: None,
            }],
            depth_stencil_attachment: Some(gpu::DepthStencilAttachment {
                image: &depth_target,
                depth_clear_value: None,
                stencil_clear_value: None,
            }),
        });
        encoder.reference_resource(&gpu_data.expansion_vertices);
        encoder.reference_resource(&gpu_data.expansion_indices);
        encoder.bind_graphics_pipeline(&*debug_stroke_pipeline);
        let index_count = strokes
            .iter()
            .map(|s| (s.vertex_count - 1) * (NVERTEX as u32 - 1) * 6)
            .sum::<u32>();

        let vertex_count = strokes.iter().map(|s| s.vertex_count).sum::<u32>();
        let stroke_count = strokes.len() as u32;
        //eprintln!("vertex_count={}", vertex_count);
        //eprintln!("stroke_count={}", stroke_count);
        //eprintln!("index_count={}", index_count);
        encoder.draw(TriangleList, 0..index_count, 0..1, &DebugStrokesRootParams {
            scene_info: scene_info.gpu,
            vertices: gpu_data.expansion_vertices.ptr(),
            indices: gpu_data.expansion_indices.ptr(),
        });

        //draw_lines(&mut encoder, &line_vertices, &lines, scene_info);

        encoder.finish();
    }
}

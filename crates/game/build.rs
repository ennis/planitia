use shader_bridge::{compile_and_embed_shaders, rustfmt_file, translate_slang_shared_decls};
use std::env;
use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};

/// Path to the shader directory.
const SHADERS_DIR: &str = "assets/shaders/";
/// Shader containing declarations shared between host & shader code.
const SLANG_SHARED: &str = "assets/shaders/shared.slang";

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let shader_bindings = out_dir.join("bindings.rs");

    {
        let mut output = File::create(&shader_bindings).unwrap();
        writeln!(
            &mut output,
            "/* This file is generated by build.rs. Do not edit this file. */"
        )
        .unwrap();

        // Translate `slang/shared.slang`
        let slang_shared = Path::new(SLANG_SHARED);
        // FIXME: this works, more or less, but RustRover doesn't update its browsing info
        //        when a shader is changed (need to clear the caches). This results in an extremely
        //        poor developer experience. There wasn't a problem when we did the opposite
        //        (generating shader code from rust structs).
        translate_slang_shared_decls(slang_shared, &mut output);

        // Compile and embed shaders
        compile_and_embed_shaders(SHADERS_DIR, &[], &out_dir, &mut output);
    }

    rustfmt_file(&shader_bindings);

    /////////////////////////////////////////

    // build shaders
    if let Err(err) = pipeline_build_lib::build_pipeline(
        "assets/shaders/pipelines.json",
        &pipeline_build_lib::BuildOptions {
            quiet: true,
            emit_cargo_deps: true,
        },
    ) {
        println!("cargo::error={err:#}");
    }
}

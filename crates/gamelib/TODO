 ✔ Create window with DXGI Swapchain & vulkan interop @done (25-08-03 17:11)
 ✔ Import graal @done (25-08-03 17:11)
 ✔ Input events @done (25-08-03 17:43)
 ✔ Simple rendering (clear color) @done (25-08-03 18:22)
 ✔ Unify statics in a single context struct @done (25-08-03 20:25)
 ✔ timers @done (25-08-21 23:33)
 ✔ collect input events @done (25-08-06 16:50)
 ✔ non-async loop handler @done (25-08-21 23:33)
 ✔ move compositor clock thread to separate module @done (25-08-22 12:36)
 ✔ quit on close @done (25-08-21 23:34)
 ✔ egui integration @done (25-08-23 17:46)
 ✔ Skip frame if late (late vsync event) @done (25-08-24 12:50)
 ☐ Create entity / serialize
 ✔ imgui: handle window resize @done (25-08-23 23:38)
 ✔ Make things debuggable with renderdoc @done (25-08-23 23:38)
 ✔ Fix egui freezing sometimes @done (25-08-23 22:28)
 ✔ Fix egui color bug @done (25-08-23 23:15)
     It was a nasty use-after-free due to slice::from_raw_parts ignoring lifetimes
 ☐ Use vulkan swapchains instead of DXGI, to make things simpler to debug @low
 ✔ Replace uses of `Device::global().function` by global functions. @done (25-11-01 10:37)
 ☐ Load mesh
 ✔ Import shader-bridge @done (25-10-06 22:26)
 ✔ move to a separate repo @done (25-10-06 22:26)
 ☐ get rid of winit
 ☐ get rid of arboard
 ☐ get rid of egui
 ☐ object picking
 ☐ arbitrary data containers based on archive format
 ☐ Mesh file format
 ☐ Move assets, painting, platform etc. to another crate for potential reuse
 ☐ async asset reloading
 ☐ move egui shaders to shader-archive
 ☐ Deprecate shader-bridge? Move functionality to shadertool
 ☐ buffer pool for uploading stuff to the GPU on each frame (use case: immediate / line rendering)
 ☐ find a better API than indexing with `Offset<>` to read archives
 ☐ "viewport" module/object that bundles the render target (the screen) with utilities to paint things on it (upload buffer, line drawing, etc.)
 ☐ GPU: avoid mistake of calling `push_constants` before setting a pipeline
 ✔ shadertool: emit debug-info (dump spirv) @done (25-12-01 23:33)
 ☐ Framework to emit/manipulate geometry from compute shaders in a unified way (polylines, meshes)
 ☐ Geometry format: make a generic file format for geometry instead of hard-coding all the different vertex and primitive types
     There are too many types of vertex formats to track, and they must be hard-coded into the file format. 
     New ones are added regularly, which requires changing the file format in a non-backwards-compatible way.
     Replace with a format agnostic geometry container, like houdini geo files, and have usage-specific schemas on top.
 ☐ Generic geometry debugging shader
     Input: geometry in any space (object, world, clip, screen), any format, any primitive kind (mesh, polyline)
     Output: flat shaded, viewport shaded, or wireframe geometry
     This will replace `draw_lines`
 ☐ @high Figure out a way to not need `reference_resource` anymore.
     Possibly: make it the user responsibility to track which frames are using the resource.
     User would call `resource.delete_later(frame_number)`. 
     Emit warning when resource is dropped without waiting for a frame first.
     Advantage: no more tracking of frame numbers per-resource.
     Drawbacks: each system needs to keep track of how their resources are used. This means
         * one more field for the last frame number
         * replacing/reallocating resources is not a simple assignment anymore; for example, if a struct field contains a resource, must move from it first, then call delete_later, then replace;
           this means that resource fields should be "Option<Resource>" to represent the intermediate state between delete_later and the reallocation. This is inacceptable.



Terrain rendering:
    ✔ Find out how to do the initial adaptive meshing @done (25-12-15 15:55)
    ☐ Draw the initial meshing
    ☐ use meshoptimizer to create clusters
    ☐ build the cluster hierarchy


World:
    ☐ Character navigation
        ☐ Navmeshes
    ☐ Third-person camera
    ☐ Character collision
    ☐ Animation
        ☐ Limb IK
    ☐ Lighting
    ☐ Mesh import
    ☐ Skinning & animated characters


2D rendering:
    ☐ Use case: GUI
    ☐ Use case: 3D overlay
    ☐ Use case: load/save vector drawings
    ☐ Use case: sprites
    ☐ Test harness for rendering
    ✔ Text @done (25-10-04 23:30)
    ☐ Font selection by name

Shaders:
    ✔ [shader-bridge] `struct ShaderLibrary`: represents a loaded/parsed slang source file (in shader-bridge), as a collection of entry points; used to retrieve ShaderEntryPoint objects @done (25-10-06 22:25)
    ✔ [shader-bridge] `struct ShaderEntryPoint`: represents a shader entry point, associated SPIR-V code & useful reflection data @done (25-10-06 22:25)

Direction:
    ☐ Figure out terrain representation 
    ☐ Repr: construction grids
    ☐ Repr: caves & cliffs
    ☐ Repr: artificial structures
    ☐ Repr: vegetation
    ☐ Repr: atmospheric effects / ambience
    ☐ Figure out object picking technique
    ☐ Identifying assets (e.g. some object references a font, then the name of the font is renamed; how do we identify the font?)
        ☐ Identify assets with GUIDs (within a project)
    ☐ Managing associated resources & cached resources
        ☐ E.g. if a font file is unloaded, should also free its associated cache entry in the global FontCollection
        ☐ E.g. if an image is unloaded, should also free associated GPU textures

Ideas:
    ☐ Idea: take satellite maps as input (w/ elevation) & generate stylized landscape from that, by pattern recognition
    ☐ Simulate electrical/communication networks

--- ✄ -----------------------


EGUI replacement:
    ✔ unify geometry/vector types via external crate (math) @done (25-10-06 22:26)
    ✔ draw rectangles @done (25-10-06 22:26)
    ✔ draw rounded rectangles @done (25-10-06 22:26)
    ☐ space allocation & layout
    ✔ text layout & rendering @done (25-10-06 22:26)

Winit replacement:
    ☐ create win32 window
    ☐ Win32 event loop
    ☐ mouse (WM_POINTER) events
    ☐ keyboard event translation
    ☐ resizing
    ☐ custom cursors 
    ☐ clipboard

Bugs:
    ☐ vkDestroySemaphore(): can't be called on VkSemaphore 0xcb1c7c000000001b[DxgiVulkanSharedFence] that is currently in use by VkQueue 0x1be997ad4c0.
    ☐ ERROR_DEVICE_LOST sometimes at startup
        \Device\Video3
        Error occurred on GPUID: 700

 ✔ Create window with DXGI Swapchain & vulkan interop @done (25-08-03 17:11)
 ✔ Import graal @done (25-08-03 17:11)
 ✔ Input events @done (25-08-03 17:43)
 ✔ Simple rendering (clear color) @done (25-08-03 18:22)
 ✔ Unify statics in a single context struct @done (25-08-03 20:25)
 ✔ timers @done (25-08-21 23:33)
 ✔ collect input events @done (25-08-06 16:50)
 ✔ non-async loop handler @done (25-08-21 23:33)
 ✔ move compositor clock thread to separate module @done (25-08-22 12:36)
 ✔ quit on close @done (25-08-21 23:34)
 ✔ egui integration @done (25-08-23 17:46)
 ✔ Skip frame if late (late vsync event) @done (25-08-24 12:50)
 ☐ Create entity / serialize
 ✔ imgui: handle window resize @done (25-08-23 23:38)
 ✔ Make things debuggable with renderdoc @done (25-08-23 23:38)
 ✔ Fix egui freezing sometimes @done (25-08-23 22:28)
 ✔ Fix egui color bug @done (25-08-23 23:15)
     It was a nasty use-after-free due to slice::from_raw_parts ignoring lifetimes
 ☐ Use vulkan swapchains instead of DXGI, to make things simpler to debug @low
 ✔ Replace uses of `Device::global().function` by global functions. @done (25-11-01 10:37)
 ☐ Load mesh
 ✔ Import shader-bridge @done (25-10-06 22:26)
 ✔ move to a separate repo @done (25-10-06 22:26)
 ☐ get rid of winit
 ☐ get rid of arboard
 ☐ get rid of egui
 ☐ object picking
 ☐ arbitrary data containers based on archive format
 ☐ Mesh file format
 ☐ Move assets, painting, platform etc. to another crate for potential reuse
 ☐ async asset reloading
 ☐ move egui shaders to shader-archive
 ☐ Deprecate shader-bridge? Move functionality to shadertool
 ☐ buffer pool for uploading stuff to the GPU on each frame (use case: immediate / line rendering)
 ☐ find a better API than indexing with `Offset<>` to read archives
     Relative pointers?
 ☐ "viewport" module/object that bundles the render target (the screen) with utilities to paint things on it (upload buffer, line drawing, etc.)
 ✔ GPU: avoid mistake of calling `push_constants` before setting a pipeline @done (25-12-21 17:21)
     setting push constants is now done at the same time as the draw call ("root parameters")
 ✔ shadertool: emit debug-info (dump spirv) @done (25-12-01 23:33)
 ✔ PushConstants (Root paramters) should be a single pointer to GPU memory (No Graphics API) @done (26-01-01 17:12)
     To avoid mistakes like putting an atomic variable in push constants
 ☐ Framework to emit/manipulate geometry from compute shaders in a unified way (polylines, meshes)
 ☐ Geometry format: make a generic file format for geometry instead of hard-coding all the different vertex and primitive types
     There are too many types of vertex formats to track, and they must be hard-coded into the file format. 
     New ones are added regularly, which requires changing the file format in a non-backwards-compatible way.
     Replace with a format agnostic geometry container, like houdini geo files, and have usage-specific schemas on top.
 ☐ Generic geometry debugging shader
     Input: geometry in any space (object, world, clip, screen), any format, any primitive kind (mesh, polyline)
     Output: flat shaded, viewport shaded, or wireframe geometry
     This will replace `draw_lines`
 ✔ Simplify buffer and image usages @done (25-12-19 14:23)
     For buffers, in nvk: SSBOs and uniforms have different alignment requirements; as do: device generated commands buffers
     no desktop driver in Mesa has special logic the following buffer bits
         * VK_BUFFER_USAGE_2_VERTEX_BUFFER_BIT / VK_BUFFER_USAGE_VERTEX_BUFFER_BIT 
         * VK_BUFFER_USAGE_2_INDEX_BUFFER_BIT  / VK_BUFFER_USAGE_INDEX_BUFFER_BIT 
         * VK_BUFFER_USAGE_2_TRANSFER_SRC_BIT / VK_BUFFER_USAGE_TRANSFER_SRC_BIT (except one broadcom driver) 
         * VK_BUFFER_USAGE_2_TRANSFER_DST_BIT / VK_BUFFER_USAGE_TRANSFER_DST_BIT
         * VK_BUFFER_USAGE_2_SHADER_DEVICE_ADDRESS_BIT
         * VK_BUFFER_USAGE_2_INDIRECT_BUFFER_BIT
     nvk uses the STORAGE and UNIFORM bits to determine the minimum alignment (STORAGE is 16, UNIFORM is 64); STORAGE is not used meaningfully anywhere else
     Image usages are harder to simplify
  ☐ Barriers are misleading: it is expected to call barrier **before** an operation to set the write flags, and then **after** the operation to sync with the next
  ✔ Inline root constants at draw call site @done (26-01-02 16:22)
  ☐ Streamline the API even more
      What we're mostly doing now
         * allocating or reallocating buffers and images and storing them in structs
         * pushing root constants
         * creating (useless) encoders for render passes
      Maybe allocate buffers declaratively, like how pipelines are specified in json.
      Not sure if it's worth it at this state, when the render pipeline isn't fully defined
         

 ✔ @high Figure out a way to not need `reference_resource` anymore. @done (25-12-21 18:24)
     Problem: `reference_resource` is needed because the layer has no way to know which resources are used when using bindless resources (texture descriptor indices & buffer addresses).
         Similar approach in Metal with `useResource`
     Possibly: make it the user responsibility to track which frames are using the resource.
     User would call `resource.delete_later(frame_number)`. 
     Emit warning when resource is dropped without waiting for a frame first.
     Advantage: no more tracking of frame numbers per-resource.
     Drawbacks: each system needs to keep track of how their resources are used. This means
         * one more field for the last frame number
         * replacing/reallocating resources is not a simple assignment anymore; for example, if a struct field contains a resource, must move from it first, then call delete_later, then replace;
           this means that resource fields should be "Option<Resource>" to represent the intermediate state between delete_later and the reallocation. This is inacceptable.
     Alternative: make resources entirely unsafe
         i.e. they are `Copy` structs that are nothing more than vulkan handle + some useful metadata
              no destructors, actually no RAII at all; they must be destroyed explicitly. 
     Alternative: `Ptr` as a borrow of the underlying buffer. This would require an object representing the current submission that `Ptr` can borrow from.
         Sounds impractical
     Alternative: automatic tracking of `Ptr` inside data passed in GPU buffers (need some kind of reflection)
         Impractical, unreliable
     Alternative: always wait for submission N-m (where m=1,2,3... aka "submissions in flight") before actually deleting the resource.
         This ensures that all dropped resources (that were dropped a few frames ago) are not in use anymore.
         Issue: submission numbers progress is not always "steady", i.e. the number of submissions in different frames can vary, leading to excessive wait.
             Solution: max number of submissions per frame (e.g. 256), then the higher order bits define the "frame number".
     Solution: on drop, just assume that the dropped resource may be used by pending command streams


 ✔ Do away with encoders @done (25-12-19 17:01)
     ComputeEncoder is strictly useless


Terrain rendering:
    ✔ Find out how to do the initial adaptive meshing @done (25-12-15 15:55)
    ☐ Draw the initial meshing
    ☐ use meshoptimizer to create clusters
    ☐ build the cluster hierarchy


World:
    ☐ Character navigation
        ☐ Navmeshes
    ☐ Third-person camera
    ☐ Character collision
    ☐ Animation
        ☐ Limb IK
    ☐ Lighting
    ☐ Mesh import
    ☐ Skinning & animated characters


2D rendering:
    ☐ Use case: GUI
    ☐ Use case: 3D overlay
    ☐ Use case: load/save vector drawings
    ☐ Use case: sprites
    ☐ Test harness for rendering
    ✔ Text @done (25-10-04 23:30)
    ☐ Font selection by name

Shaders:
    ✔ [shader-bridge] `struct ShaderLibrary`: represents a loaded/parsed slang source file (in shader-bridge), as a collection of entry points; used to retrieve ShaderEntryPoint objects @done (25-10-06 22:25)
    ✔ [shader-bridge] `struct ShaderEntryPoint`: represents a shader entry point, associated SPIR-V code & useful reflection data @done (25-10-06 22:25)

Direction:
    ☐ Figure out terrain representation 
    ☐ Repr: construction grids
    ☐ Repr: caves & cliffs
    ☐ Repr: artificial structures
    ☐ Repr: vegetation
    ☐ Repr: atmospheric effects / ambience
    ☐ Figure out object picking technique
    ☐ Identifying assets (e.g. some object references a font, then the name of the font is renamed; how do we identify the font?)
        ☐ Identify assets with GUIDs (within a project)
    ☐ Managing associated resources & cached resources
        ☐ E.g. if a font file is unloaded, should also free its associated cache entry in the global FontCollection
        ☐ E.g. if an image is unloaded, should also free associated GPU textures

Ideas:
    ☐ Idea: take satellite maps as input (w/ elevation) & generate stylized landscape from that, by pattern recognition
    ☐ Simulate electrical/communication networks

--- ✄ -----------------------


EGUI replacement:
    ✔ unify geometry/vector types via external crate (math) @done (25-10-06 22:26)
    ✔ draw rectangles @done (25-10-06 22:26)
    ✔ draw rounded rectangles @done (25-10-06 22:26)
    ☐ space allocation & layout
    ✔ text layout & rendering @done (25-10-06 22:26)

Winit replacement:
    ☐ create win32 window
    ☐ Win32 event loop
    ☐ mouse (WM_POINTER) events
    ☐ keyboard event translation
    ☐ resizing
    ☐ custom cursors 
    ☐ clipboard

Bugs:
    ☐ vkDestroySemaphore(): can't be called on VkSemaphore 0xcb1c7c000000001b[DxgiVulkanSharedFence] that is currently in use by VkQueue 0x1be997ad4c0.
    ☐ ERROR_DEVICE_LOST sometimes at startup
        \Device\Video3
        Error occurred on GPUID: 700
